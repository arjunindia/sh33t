<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 16px;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        #sheet-grid-container {
            margin-top: 8.5vh;
            width: 100%;
            height: calc(100vh - 10vh);
            /* Adjust height to fill remaining viewport */
            overflow: hidden;
            position: relative;
            display: flex;
            /* Use flexbox for overall layout */
            flex-direction: column;
        }

        :root {
            --column-width: 100px;
            /* Define a CSS variable for column width */
            --row-header-width: 50px;
            /* Define a CSS variable for row header width */
            --total-columns: 50;
            /* Will be set by JS */
        }

        #sheet-grid-header {
            display: flex;
            /* Use flexbox to align corner cell and column headers content */
            grid-gap: 1px;
            background-color: lightgray;
            flex-shrink: 0;
            /* Don't shrink header */
            overflow: hidden;
            /* Hide overflow to prevent scrollbar on header itself */
            position: sticky;
            top: 0;
            z-index: 3;
        }

        #column-headers-content {
            display: grid;
            grid-template-columns: repeat(var(--total-columns), var(--column-width));
            /* All columns for layout */
            grid-gap: 1px;
            width: calc(var(--total-columns) * var(--column-width) + (var(--total-columns) - 1) * 1px);
            /* Total width including gaps */
            position: relative;
            /* For transform translateX */
            left: 0;
        }

        .corner-cell,
        .column-header-cell {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            height: 30px;
            line-height: 20px;
            padding: 5px;
            text-align: center;
            font-weight: bold;
            width: var(--column-width);
            /* Apply fixed width */
            flex-shrink: 0;
        }

        .corner-cell {
            width: var(--row-header-width);
        }

        #sheet-grid-viewport {
            width: 100%;
            flex-grow: 1;
            /* Allow viewport to take remaining height */
            overflow: auto;
            position: relative;
            display: flex;
            /* Use flexbox for viewport content */
        }

        #row-headers {
            width: 50px;
            /* Fixed width for row headers */
            flex-shrink: 0;
            background-color: lightgray;
            position: sticky;
            /* Make row headers sticky */
            left: 0;
            z-index: 2;
        }

        .row-header-cell {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            height: 30px;
            line-height: 20px;
            padding: 5px;
            text-align: center;
            font-weight: bold;
            position: absolute;
            /* Position row headers absolutely */
            width: 100%;
            left: 0;
        }

        #sheet-grid-content {
            position: relative;
            /* Make it a positioning context for absolute rows */
            flex-grow: 1;
            /* Allow content to take remaining width */
            /* Its height will be set dynamically by JS to TOTAL_ROWS * ROW_HEIGHT */
        }

        .sheet-grid-row {
            position: absolute;
            /* Position rows absolutely within the content div */
            left: 0;
            width: calc(var(--total-columns) * var(--column-width) + (var(--total-columns) - 1) * 1px);
            /* Total width including gaps */
            display: grid;
            grid-template-columns: repeat(var(--total-columns), var(--column-width));
            /* All columns for layout */
            grid-gap: 1px;
            background-color: lightgray;
            /* For row separation */
        }

        .sheet-grid-cell {
            background-color: white;
            border: 1px solid #ccc;
            /* Lighter border for cells */
            padding: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            height: 30px;
            /* Fixed cell height */
            line-height: 20px;
            /* Center text vertically */
        }

        .sheet-grid-cell-input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 5px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
            /* Remove outline on focus */
        }

        .sheet-grid-cell:hover {
            background-color: lightblue;
        }

        .sheet-grid-cell:focus,
        .sheet-grid-cell.focused {
            background-color: lightcoral;
        }

        div[role="menubar"] {
            display: flex;
            /* background-color: lightgray; */
            padding: 5px;
            position: relative;
        }

        #top-level-menu {
            display: flex;
            flex-direction: row;
        }

        div[role="menu"] {
            flex-direction: column;
            background-color: white;
            border: 1px solid black;
            position: absolute;
            z-index: 10;
            min-width: 120px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        div[role="menuitem"] {
            padding: 8px 12px;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        div[role="menuitem"] span {
            margin-left: 20px; /* Adjust as needed for spacing */
            color: #666; /* Lighter color for shortcuts */
            font-size: 0.9em; /* Slightly smaller font size */
        }

        div[role="menuitem"]:hover {
            background-color: lightblue;
        }

        .menu-closed {
            display: none;
        }

        .menu-open {
            display: flex;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 100; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be responsive */
            max-width: 500px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
            animation-name: animatetop;
            animation-duration: 0.4s
        }

        /* Add Animation */
        @-webkit-keyframes animatetop {
            from {top:-300px; opacity:0}
            to {top:0; opacity:1}
        }

        @keyframes animatetop {
            from {top:-300px; opacity:0}
            to {top:0; opacity:1}
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Tooltip Styles */
        .cell-tooltip {
            position: absolute;
            background-color: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
            white-space: normal;
        }

        .modal-content label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .modal-content input[type="text"],
        .modal-content input[type="password"],
        .modal-content textarea,
        .modal-content select {
            width: calc(100% - 10px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-content button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .modal-content button:hover {
            background-color: #45a049;
        }
    </style>
</head>

<body>
    <!-- top menu (File, Edit, View, Help) -->
    <div aria-label="top menu" role="menubar">
        <div role="menu" id="top-level-menu">
            <div role="menuitem" class="menu-item" id="file-menu-item" data-submenu="file-submenu">File</div>
            <div role="menuitem" class="menu-item" id="edit-menu-item" data-submenu="edit-submenu">Edit</div>
            <div role="menuitem" class="menu-item" id="ai-menu-item" data-submenu="ai-submenu">AI</div>
        </div>
            <div role="menu" aria-label="File menu" class="menu-closed" id="file-submenu">
                <div role="menuitem" class="menu-item" id="new-file-menu-item">New <span>Ctrl+N</span></div>
                <div role="menuitem" class="menu-item" id="save-as-csv-menu-item">Save as CSV <span>Ctrl+S</span></div>
                <div role="menuitem" class="menu-item" id="open-csv-menu-item">Open CSV <span>Ctrl+O</span></div>
            </div>
            <div role="menu" aria-label="Edit menu" class="menu-closed" id="edit-submenu">
                <div role="menuitem" class="menu-item" id="undo-menu-item">Undo <span>Ctrl+Z</span></div>
                <div role="menuitem" class="menu-item" id="redo-menu-item">Redo <span>Ctrl+Shift+Z</span></div>
                <div role="menuitem" class="menu-item" data-action="cut" id="cut-menu-item">Cut <span>Ctrl+X</span></div>
                <div role="menuitem" class="menu-item" data-action="copy" id="copy-menu-item">Copy <span>Ctrl+C</span></div>
                <div role="menuitem" class="menu-item" data-action="copy-value" id="copy-value-menu-item">Copy Value <span>Ctrl+Shift+C</span></div>
                <div role="menuitem" class="menu-item" data-action="paste" id="paste-menu-item">Paste <span>Ctrl+V</span></div>
                <div role="menuitem" class="menu-item" data-action="delete" id="delete-menu-item">Delete <span>Del</span></div>
            </div>
            <div role="menu" aria-label="AI menu" class="menu-closed" id="ai-submenu">
                <div role="menuitem" class="menu-item" id="ai-settings-menu-item">Settings <span>Ctrl+Alt+S</span></div>
                <div role="menuitem" class="menu-item" id="ai-ask-menu-item">Ask AI <span>Ctrl+Alt+A</span></div>
            </div>
        </div>
        <!-- Sheet grid -->
    <div id="sheet-grid-container">
        <div id="sheet-grid-header">
            <div class="corner-cell"></div>
            <div id="column-headers-content">
                <!-- Column headers will be generated by JS -->
            </div>
        </div>
        <div id="sheet-grid-viewport">
            <div id="row-headers">
                <!-- Row headers will be generated by JS -->
            </div>
            <div id="sheet-grid-content"></div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="aiSettingsModal" class="modal">
        <div class="modal-content">
            <button class="close-button" aria-label="Close AI Settings">&times;</button>
            <h2>AI Settings</h2>
            <label for="apiBaseUrl">API Base URL:</label>
            <input type="text" id="apiBaseUrl" placeholder="e.g., https://api.openai.com/v1">

            <label for="apiKey">API Key:</label>
            <input type="password" id="apiKey" placeholder="Your OpenAI API Key">

            <label for="aiModel">AI Model:</label>
            <input type="text" id="aiModel" placeholder="e.g., gpt-3.5-turbo">

            <button id="saveAiSettings">Save Settings</button>
        </div>
    </div>

    <!-- Ask AI Modal -->
    <div id="askAiModal" class="modal">
        <div class="modal-content">
            <button class="close-button" aria-label="Close Ask AI">&times;</button>
            <h2>Ask AI</h2>
            <label for="aiPrompt">Enter your prompt:</label>
            <textarea id="aiPrompt" rows="6" placeholder="Describe what you want the AI to do with the sheet data..."></textarea>

            <button id="submitAiPrompt">Submit</button>
        </div>
    </div>

    <!-- Cell Tooltip -->
    <div id="cellTooltip" class="cell-tooltip"></div>

    <!-- Script -->
    <script>
        const menubar = document.querySelector('div[role="menubar"]');
        const topMenu = document.getElementById('top-level-menu');
        let activeSubmenu = null;
        let isMenuInteraction = false; // New flag to track menu interaction

        // AI Settings elements
        const aiSettingsModal = document.getElementById('aiSettingsModal');
        const closeButton = aiSettingsModal.querySelector('.close-button');
        const apiBaseUrlInput = document.getElementById('apiBaseUrl');
        const apiKeyInput = document.getElementById('apiKey');
        const aiModelInput = document.getElementById('aiModel');
        const saveAiSettingsButton = document.getElementById('saveAiSettings');
        const aiSettingsMenuItem = document.getElementById('ai-settings-menu-item');
        const askAiModal = document.getElementById('askAiModal');
        const aiPromptInput = document.getElementById('aiPrompt');
        const submitAiPromptButton = document.getElementById('submitAiPrompt');
        const aiAskMenuItem = document.getElementById('ai-ask-menu-item');

        // Load AI settings from localStorage
        let aiConfig = JSON.parse(localStorage.getItem('aiConfig')) || {
            apiBaseUrl: 'https://api.openai.com/v1',
            apiKey: '',
            aiModel: 'gpt-3.5-turbo'
        };

        // Function to save AI settings to localStorage
        function saveAiSettings() {
            aiConfig.apiBaseUrl = apiBaseUrlInput.value;
            aiConfig.apiKey = apiKeyInput.value;
            aiConfig.aiModel = aiModelInput.value;
            localStorage.setItem('aiConfig', JSON.stringify(aiConfig));
            aiSettingsModal.style.display = 'none';
            console.log('AI Settings saved:', aiConfig);
        }

        // Function to trap focus within modal
        function trapFocus(modal, initialFocus) {
            const focusableElements = modal.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            function handleKeyDown(e) {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        // Shift + Tab
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        // Tab
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                } else if (e.key === 'Escape') {
                    // Close modal on Escape
                    modal.style.display = 'none';
                }
            }

            modal.addEventListener('keydown', handleKeyDown);

            // Store the cleanup function
            modal._cleanupFocusTrap = () => {
                modal.removeEventListener('keydown', handleKeyDown);
            };

            // Initial focus
            if (initialFocus) {
                requestAnimationFrame(() => {
                    initialFocus.focus();
                });
            }
        }

        // Function to open AI settings modal
        function openAiSettingsModal() {
            apiBaseUrlInput.value = aiConfig.apiBaseUrl;
            apiKeyInput.value = aiConfig.apiKey;
            aiModelInput.value = aiConfig.aiModel;
            aiSettingsModal.style.display = 'flex'; // Use flex to center modal
            trapFocus(aiSettingsModal, apiBaseUrlInput);
        }

        function openAskAiModal() {
            aiPromptInput.value = '';
            askAiModal.style.display = 'flex';
            trapFocus(askAiModal, aiPromptInput);
        }

        function collectSheetData() {
            const data = [];
            for (let i = 0; i < TOTAL_ROWS; i++) {
                for (let j = 0; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    const value = cellValues.get(cellId);
                    const formula = cellFormulas.get(cellId);
                    if (value || formula) {
                        const display = formula ? `${formula} (${value})` : value;
                        data.push(`${cellId}: ${display}`);
                    }
                }
            }
            return data.join(', ');
        }

        function applyAiUpdates(updates) {
            const changes = [];
            for (const [cellId, newValue] of Object.entries(updates)) {
                const oldValue = cellValues.get(cellId);
                const oldFormula = cellFormulas.get(cellId);
                cellValues.set(cellId, newValue);
                cellFormulas.set(cellId, ''); // Assuming updates are direct values, not formulas
                recordChange(cellId, oldValue, oldFormula, newValue, '');
                changes.push(cellId);
            }
            reEvaluateAllCells();
            // Re-render visible rows
            renderRows();
            console.log('Applied AI updates to cells:', changes);
        }

        function processAiPrompt(prompt) {
            // Collect sheet data
            const sheetData = collectSheetData();

            // Format the full prompt
            const fullPrompt = `Current sheet data:\n${sheetData}\n\nUser request: ${prompt}\n\nPlease provide updates in JSON format like: {"A1": "new value", "B2": "new value2"}\n Think of the spreadsheet format , cells go A1, A2... and B1, B2... etc. \nYour response should only include the JSON object. No codeblocks, tags or anything.`;

            // Show loading
            submitAiPromptButton.disabled = true;
            submitAiPromptButton.textContent = 'Processing...';

            // Call AI
            fetchAiResponse(fullPrompt).then(response => {
                try {
                    const updates = JSON.parse(response);
                    applyAiUpdates(updates);
                    askAiModal.style.display = 'none';
                    alert('Sheet updated successfully!');
                } catch (e) {
                    alert('Failed to parse AI response. Please try again.');
                    console.error('JSON parse error:', e);
                }
                console.log('AI response:', response);

            }).catch(error => {
                alert('Error processing AI request: ' + error.message);
                console.error('AI request error:', error);
            }).finally(() => {
                submitAiPromptButton.disabled = false;
                submitAiPromptButton.textContent = 'Submit';
            });
        }

        // Event listeners for AI settings modal
        aiSettingsMenuItem.addEventListener('click', (e) => {
            e.stopPropagation();
            openAiSettingsModal();
            if (activeSubmenu) {
                activeSubmenu.classList.remove('menu-open');
                activeSubmenu = null;
            }
            isMenuInteraction = false;
        });

        closeButton.addEventListener('click', () => {
            aiSettingsModal.style.display = 'none';
            // Clean up focus trap
            if (aiSettingsModal._cleanupFocusTrap) {
                aiSettingsModal._cleanupFocusTrap();
            }
        });

        saveAiSettingsButton.addEventListener('click', saveAiSettings);

        window.addEventListener('click', (e) => {
            if (e.target === aiSettingsModal) {
                aiSettingsModal.style.display = 'none';
                // Clean up focus trap
                if (aiSettingsModal._cleanupFocusTrap) {
                    aiSettingsModal._cleanupFocusTrap();
                }
            }
        });

        // Ask AI modal event listeners
        aiAskMenuItem.addEventListener('click', (e) => {
            e.stopPropagation();
            openAskAiModal();
            if (activeSubmenu) {
                activeSubmenu.classList.remove('menu-open');
                activeSubmenu = null;
            }
            isMenuInteraction = false;
        });

        const askAiCloseButton = askAiModal.querySelector('.close-button');
        askAiCloseButton.addEventListener('click', () => {
            askAiModal.style.display = 'none';
            // Clean up focus trap
            if (askAiModal._cleanupFocusTrap) {
                askAiModal._cleanupFocusTrap();
            }
        });

        window.addEventListener('click', (e) => {
            if (e.target === askAiModal) {
                askAiModal.style.display = 'none';
                // Clean up focus trap
                if (askAiModal._cleanupFocusTrap) {
                    askAiModal._cleanupFocusTrap();
                }
            }
        });

        submitAiPromptButton.addEventListener('click', () => {
            const prompt = aiPromptInput.value.trim();
            if (prompt) {
                processAiPrompt(prompt);
            }
        });

        // Add mousedown listener to top-level menu items to set isMenuInteraction flag early
        topMenu.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                isMenuInteraction = true; // Set flag immediately on mousedown
            });
        });

        topMenu.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const submenuId = item.dataset.submenu;
                const submenu = document.getElementById(submenuId);

                if (activeSubmenu && activeSubmenu !== submenu) {
                    activeSubmenu.classList.remove('menu-open');
                }

                if (submenu) {
                    submenu.classList.toggle('menu-open');
                    if (submenu.classList.contains('menu-open')) {
                        const rect = item.getBoundingClientRect();
                        submenu.style.top = `${rect.bottom + window.scrollY}px`;
                        submenu.style.left = `${rect.left + window.scrollX}px`;
                        activeSubmenu = submenu;
                        // isMenuInteraction is already true from mousedown
                    } else {
                        activeSubmenu = null;
                        isMenuInteraction = false; // Menu closed by clicking its own top-level item
                    }
                }
            });
        });

        // Handle clicks on submenu items
        document.querySelectorAll('#file-submenu .menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const menuItemId = item.id;

                if (menuItemId === 'new-file-menu-item') {
                    resetSheet();
                } else if (menuItemId === 'save-as-csv-menu-item') {
                    saveAsCSV();
                } else if (menuItemId === 'open-csv-menu-item') {
                    openCSV();
                }

                // Close the submenu after action
                if (activeSubmenu) {
                    activeSubmenu.classList.remove('menu-open');
                    activeSubmenu = null;
                }
                isMenuInteraction = false;
            });
        });

        document.querySelectorAll('#edit-submenu .menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = item.dataset.action;
                const menuItemId = item.id;

                if (menuItemId === 'undo-menu-item') {
                    undo();
                } else if (menuItemId === 'redo-menu-item') {
                    redo();
                } else if (currentFocusedCellId) {
                    switch (action) {
                        case 'cut':
                            cutCell(currentFocusedCellId);
                            break;
                        case 'copy':
                            copyCell(currentFocusedCellId);
                            break;
                        case 'copy-value':
                            copyCellValue(currentFocusedCellId);
                            break;
                        case 'paste':
                            pasteCell(currentFocusedCellId);
                            break;
                        case 'delete':
                            deleteCell(currentFocusedCellId);
                            break;
                    }
                }
                // Close the submenu after action
                if (activeSubmenu) {
                    activeSubmenu.classList.remove('menu-open');
                    activeSubmenu = null;
                }
                // Re-focus the cell after action, but only if it's not an undo/redo operation
                // Undo/Redo might change the content of the focused cell, but not necessarily blur it.
                if (currentFocusedCellId && menuItemId !== 'undo-menu-item' && menuItemId !== 'redo-menu-item') {
                    requestAnimationFrame(() => {
                        const cellToRefocus = document.querySelector(`.sheet-grid-cell[data-cell-id="${currentFocusedCellId}"]`);
                        if (cellToRefocus) {
                            cellToRefocus.focus();
                            currentFocusedCellElement = cellToRefocus; // Update the element reference
                        }
                    });
                    isMenuInteraction = false; // Reset flag AFTER re-focus attempt
                } else {
                    isMenuInteraction = false; // If no cell to re-focus, reset immediately
                }
            });
        });

        document.addEventListener('click', (e) => {
            // Only close the submenu if the click is outside the menubar AND a submenu is open
            if (activeSubmenu && !menubar.contains(e.target)) {
                activeSubmenu.classList.remove('menu-open');
                activeSubmenu = null;
                isMenuInteraction = false; // Reset flag when global click closes menu
            }
            // If a menu item was clicked, we explicitly re-focus the cell in the menu item's click handler.
            // So, we don't want this global click handler to blur the cell.
            // However, if the click is outside the menubar and not on a cell, we should allow blur.
            // The currentFocusedCellElement will handle removing the 'focused' class on blur.
        });

        // Virtual Scrolling Spreadsheet Logic
        // Virtual Scrolling Spreadsheet Logic
        const viewport = document.getElementById('sheet-grid-viewport');
        const content = document.getElementById('sheet-grid-content');
        const columnHeaderContainer = document.querySelector('#sheet-grid-header');
        const columnHeadersContent = document.getElementById('column-headers-content'); // New reference
        const rowHeaderContainer = document.getElementById('row-headers');
        const tooltip = document.getElementById('cellTooltip');

        const ROW_HEIGHT = 30; // Must match .sheet-grid-cell height
        const COLUMN_WIDTH = 100; // Must match --column-width in CSS
        const ROW_HEADER_WIDTH = 50; // Must match --row-header-width in CSS

        const TOTAL_ROWS = 1000; // Total number of rows in the virtual grid
        const TOTAL_COLUMNS = 50; // Total number of columns in the virtual grid (e.g., A-AX)
        document.documentElement.style.setProperty('--total-columns', TOTAL_COLUMNS);

        // Maps to store cell values and formulas
        const cellValues = new Map(); // Key: "A1", Value: "Hello"
        const cellFormulas = new Map(); // Key: "A1", Value: "=SUM(B1:C1)"
        let currentFocusedCellId = null; // To keep track of the currently focused cell
        let currentFocusedCellElement = null; // Track the actual DOM element
        let clipboard = {
            type: null, // 'copy' or 'cut'
            cellId: null,
            value: null,
            formula: null
        };

        // Undo/Redo History
        const history = [];
        let historyPointer = -1;
        const MAX_HISTORY_SIZE = 100; // Limit history size

        function recordChange(cellId, oldValue, oldFormula, newValue, newFormula) {
            // Only record if there's an actual change
            if (oldValue === newValue && oldFormula === newFormula) {
                return;
            }

            // If we've undone some actions, clear any "future" history
            if (historyPointer < history.length - 1) {
                history.splice(historyPointer + 1);
            }

            history.push({ cellId, oldValue, oldFormula, newValue, newFormula });
            historyPointer++;

            if (history.length > MAX_HISTORY_SIZE) {
                history.shift(); // Remove oldest entry
                historyPointer--;
            }
            console.log('History:', history);
        }

        function undo() {
            if (historyPointer < 0) {
                console.log('Nothing to undo.');
                return;
            }

            const lastChange = history[historyPointer];
            const { cellId, oldValue, oldFormula } = lastChange;

            // Apply the old state
            cellValues.set(cellId, oldValue);
            cellFormulas.set(cellId, oldFormula);

            historyPointer--;
            reEvaluateAllCells();
            console.log(`Undo: Reverted ${cellId} to value "${oldValue}" and formula "${oldFormula}"`);
            // Re-render the specific cell if it's visible
            const cellElement = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellId}"]`);
            if (cellElement) {
                cellElement.textContent = evaluateCell(cellId);
            }
        }

        function redo() {
            if (historyPointer >= history.length - 1) {
                console.log('Nothing to redo.');
                return;
            }

            historyPointer++;
            const nextChange = history[historyPointer];
            const { cellId, newValue, newFormula } = nextChange;

            // Apply the new state
            cellValues.set(cellId, newValue);
            cellFormulas.set(cellId, newFormula);

            reEvaluateAllCells();
            console.log(`Redo: Applied ${cellId} with value "${newValue}" and formula "${newFormula}"`);
            // Re-render the specific cell if it's visible
            const cellElement = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellId}"]`);
            if (cellElement) {
                cellElement.textContent = evaluateCell(cellId);
            }
        }

        // Helper to convert column index to A, B, C...
        function getColumnName(colIdx) {
            let name = '';
            let dividend = colIdx + 1;
            let modulo;
            while (dividend > 0) {
                modulo = (dividend - 1) % 26;
                name = String.fromCharCode(65 + modulo) + name;
                dividend = Math.floor((dividend - modulo) / 26);
            }
            return name;
        }

        // Helper to convert A, B, C... to column index
        function getColumnIdx(columnName) {
            let idx = 0;
            for (let i = 0; i < columnName.length; i++) {
                idx = idx * 26 + (columnName.charCodeAt(i) - 65 + 1);
            }
            return idx - 1; // Convert to 0-indexed
        }

        // Helper to parse a cell reference like "A1" into { col: 0, row: 0 } (0-indexed)
        function parseCellReference(cellRef) {
            const match = cellRef.match(/^([A-Z]+)(\d+)$/);
            if (!match) return null;
            const colName = match[1];
            const rowNum = parseInt(match[2], 10);
            return {
                col: getColumnIdx(colName),
                row: rowNum - 1
            };
        }

        // Initialize data (for demonstration purposes)
        for (let i = 0; i < TOTAL_ROWS; i++) {
            for (let j = 0; j < TOTAL_COLUMNS; j++) {
                const cellId = `${getColumnName(j)}${i + 1}`;
                cellValues.set(cellId, ''); // Initialize with empty string
                cellFormulas.set(cellId, ''); // No formula by default
            }
        }

        // Function to fetch AI response
        async function fetchAiResponse(prompt) {
            if (!navigator.onLine) {
                return 'Offline mode: AI features are not available. Please check your internet connection.';
            }

            if (!aiConfig.apiKey || !aiConfig.apiBaseUrl || !aiConfig.aiModel) {
                console.error('AI settings are not configured. Please set API Base URL, API Key, and AI Model in AI Settings.');
                return '#AI_CONFIG_ERROR!';
            }

            try {
                if(aiConfig.apiBaseUrl.endsWith('/')) {
                    aiConfig.apiBaseUrl = aiConfig.apiBaseUrl.slice(0, -1);
                }
                const response = await fetch(aiConfig.apiBaseUrl + '/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${aiConfig.apiKey}`,
                        'x-stainless-arch': null,
                        'x-stainless-lang': null,
                        'x-stainless-os': null,
                        'x-stainless-package-version': null,
                        'x-stainless-retry-count': null,
                        'x-stainless-runtime': null,
                        'x-stainless-runtime-version': null,
                        'x-stainless-timeout': null,
                        "anthropic-dangerous-direct-browser-access": "true",
                        
                    },
                    body: JSON.stringify({
                        model: aiConfig.aiModel,
                        messages: [{ role: 'user', content: prompt }],
                        max_tokens: 150
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('AI API Error:', errorData);
                    return `#AI_ERROR: ${errorData.error ? errorData.error.message : response.statusText}`;
                }

                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('Error fetching AI response:', error);
                return `#AI_FETCH_ERROR: ${error.message}`;
            }
        }

        // Function to evaluate a cell's formula
        function evaluateCell(cellId) {
            const formula = cellFormulas.get(cellId);
            if (!formula || !formula.startsWith('=')) {
                // If it's not a formula, return the raw value (or 0 if it's empty and we're doing calculations)
                const value = cellValues.get(cellId);
                return isNaN(parseFloat(value)) ? value : parseFloat(value);
            }

            let expression = formula.substring(1); // Remove the '='

            // Handle AI formula
            if (expression.startsWith('AI(') && expression.endsWith(')')) {
                // For AI formulas, we return the *current* evaluated value from cellValues
                // The actual AI call and update happens in saveCell
                return cellValues.get(cellId) || '#AI_PENDING...';
            }

            // Helper to get a cell's numeric value
            const getCellValue = (ref) => {
                const parsedRef = parseCellReference(ref);
                if (!parsedRef) return NaN;
                const id = `${getColumnName(parsedRef.col)}${parsedRef.row + 1}`;
                const value = cellValues.get(id);
                return isNaN(parseFloat(value)) ? 0 : parseFloat(value);
            };

            // Handle SUM and AVERAGE functions
            expression = expression.replace(/(SUM|AVERAGE)\(([A-Z]+\d+):([A-Z]+\d+)\)/g, (match, func, startRef, endRef) => {
                const start = parseCellReference(startRef);
                const end = parseCellReference(endRef);

                if (!start || !end) return '#ERROR!';

                let sum = 0;
                let count = 0;
                for (let r = start.row; r <= end.row; r++) {
                    for (let c = start.col; c <= end.col; c++) {
                        const currentCellId = `${getColumnName(c)}${r + 1}`;
                        const val = evaluateCell(currentCellId); // Recursively evaluate
                        if (!isNaN(val)) {
                            sum += val;
                            count++;
                        }
                    }
                }

                if (func === 'SUM') return sum;
                if (func === 'AVERAGE') return count === 0 ? 0 : sum / count;
                return '#ERROR!';
            });

            // Replace cell references (e.g., A1, B2) with their evaluated values
            expression = expression.replace(/[A-Z]+\d+/g, (ref) => {
                return getCellValue(ref);
            });

            try {
                // Use Function constructor for safe evaluation of arithmetic expressions
                const result = new Function('return ' + expression)();
                return result;
            } catch (e) {
                console.error(`Error evaluating formula for ${cellId}: ${formula}`, e);
                return '#ERROR!';
            }
        }

        // Function to re-evaluate all cells that contain formulas
        function reEvaluateAllCells() {
            const cellsToUpdate = [];
            for (const [cellId, formula] of cellFormulas.entries()) {
                if (formula.startsWith('=')) {
                    cellsToUpdate.push(cellId);
                }
            }

            // Evaluate in a stable order (e.g., row by row, column by column)
            // This simple approach might not handle circular dependencies, but is good for basic cases
            for (let i = 0; i < TOTAL_ROWS; i++) {
                for (let j = 0; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    if (cellsToUpdate.includes(cellId)) {
                        const evaluatedValue = evaluateCell(cellId);
                        cellValues.set(cellId, evaluatedValue);
                    }
                }
            }
            renderRows(); // Re-render visible rows to show updated values
        }

        // Calculate how many rows/columns can fit in the viewport
        let viewportHeight = viewport.clientHeight;
        let viewportWidth = viewport.clientWidth - ROW_HEADER_WIDTH; // Subtract row header width

        let visibleRows = Math.ceil(viewportHeight / ROW_HEIGHT);
        let visibleColumns = Math.ceil(viewportWidth / COLUMN_WIDTH);

        let startRowIdx = 0;
        let endRowIdx = startRowIdx + visibleRows;
        let startColIdx = 0;
        let endColIdx = startColIdx + visibleColumns;

        // Set the total height and width of the content divs to enable scrolling
        content.style.height = `${TOTAL_ROWS * ROW_HEIGHT}px`;
        content.style.width = `${TOTAL_COLUMNS * COLUMN_WIDTH}px`;
        rowHeaderContainer.style.height = `${TOTAL_ROWS * ROW_HEIGHT}px`;

        // Set the total height and width of the content divs to enable scrolling
        content.style.height = `${TOTAL_ROWS * ROW_HEIGHT}px`;
        content.style.width = `${TOTAL_COLUMNS * COLUMN_WIDTH}px`;
        rowHeaderContainer.style.height = `${TOTAL_ROWS * ROW_HEIGHT}px`;

        // The width of columnHeaderContainer is now implicitly handled by its flex children and grid-template-columns on columnHeadersContent


        function renderColumnHeaders() {
            const fragment = document.createDocumentFragment();
            // Clear existing headers from the new content div
            columnHeadersContent.innerHTML = '';

            // The grid-template-columns for the header is now set by CSS variable --total-columns
            // We render all column headers into the content div, and translateX will shift them
            for (let j = 0; j < TOTAL_COLUMNS; j++) {
                const colHeaderDiv = document.createElement('div');
                colHeaderDiv.className = 'column-header-cell';
                colHeaderDiv.textContent = getColumnName(j);
                // No gridColumnStart needed here, as the grid itself will position them
                fragment.appendChild(colHeaderDiv);
            }
            columnHeadersContent.appendChild(fragment);
        }

        function renderRows() {
            const contentFragment = document.createDocumentFragment();
            const rowHeaderFragment = document.createDocumentFragment();

            for (let i = startRowIdx; i < endRowIdx && i < TOTAL_ROWS; i++) {
                // Render row headers
                const rowHeaderDiv = document.createElement('div');
                rowHeaderDiv.className = 'row-header-cell';
                rowHeaderDiv.textContent = i + 1;
                rowHeaderDiv.style.top = `${i * ROW_HEIGHT}px`;
                rowHeaderDiv.style.height = `${ROW_HEIGHT}px`;
                rowHeaderFragment.appendChild(rowHeaderDiv);

                // Render grid rows
                const rowDiv = document.createElement('div');
                rowDiv.className = 'sheet-grid-row';
                rowDiv.style.height = `${ROW_HEIGHT}px`;
                rowDiv.style.top = `${i * ROW_HEIGHT}px`; // Position row absolutely
                // No need to set left or width here, CSS grid handles it

                for (let j = startColIdx; j < endColIdx && j < TOTAL_COLUMNS; j++) { // Only render visible columns
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'sheet-grid-cell';
                    cellDiv.textContent = cellValues.get(cellId); // Get value from map
                    cellDiv.style.gridColumnStart = j + 1; // Position cell in the correct grid column
                    cellDiv.setAttribute('tabindex', '0'); // Make cell focusable
                    cellDiv.setAttribute('data-cell-id', cellId); // Store cell ID

                    // If this cell was the one previously focused, apply the class
                    if (cellId === currentFocusedCellId) {
                        cellDiv.classList.add('focused');
                        currentFocusedCellElement = cellDiv; // Update the element reference
                    }

                    cellDiv.addEventListener('dblclick', () => editCell(cellDiv));
                    cellDiv.addEventListener('focus', () => {
                        if (currentFocusedCellElement && currentFocusedCellElement !== cellDiv) {
                            currentFocusedCellElement.classList.remove('focused');
                        }
                        currentFocusedCellId = cellId;
                        currentFocusedCellElement = cellDiv;
                        currentFocusedCellElement.classList.add('focused');

                        // Show tooltip if content is long
                        const content = cellDiv.textContent.trim();
                        if (content.length > 12 && content !== '') {
                            const rect = cellDiv.getBoundingClientRect();
                            tooltip.textContent = content;
                            tooltip.style.left = `${rect.left + window.scrollX}px`;
                            tooltip.style.top = `${rect.bottom + window.scrollY + 5}px`;
                            tooltip.style.display = 'block';
                        }
                    });
                    cellDiv.addEventListener('blur', () => {
                        // Prevent blur if a menu interaction is active
                        if (isMenuInteraction) {
                            return;
                        }

                        if (currentFocusedCellElement === cellDiv) {
                            currentFocusedCellElement.classList.remove('focused');
                            currentFocusedCellId = null;
                            currentFocusedCellElement = null;
                            tooltip.style.display = 'none'; // Hide tooltip
                        }
                    });
                    rowDiv.appendChild(cellDiv);
                }
                contentFragment.appendChild(rowDiv);
            }
            content.innerHTML = ''; // Clear existing rows
            content.appendChild(contentFragment);

            rowHeaderContainer.innerHTML = ''; // Clear existing row headers
            rowHeaderContainer.appendChild(rowHeaderFragment);
        }

        function handleScroll() {
            const scrollTop = viewport.scrollTop;
            const scrollLeft = viewport.scrollLeft;

            const newStartRowIdx = Math.floor(scrollTop / ROW_HEIGHT);
            const newStartColIdx = Math.floor(scrollLeft / COLUMN_WIDTH);

            let needsRender = false;

            if (newStartRowIdx !== startRowIdx) {
                startRowIdx = newStartRowIdx;
                endRowIdx = Math.min(startRowIdx + visibleRows, TOTAL_ROWS);
                needsRender = true;
            }

            if (newStartColIdx !== startColIdx) {
                startColIdx = newStartColIdx;
                endColIdx = Math.min(startColIdx + visibleColumns, TOTAL_COLUMNS);
                needsRender = true;
            }

            if (needsRender) {
                renderColumnHeaders(); // Re-render column headers for horizontal scroll
                renderRows();
            }

            // Synchronize horizontal scroll for column headers
            columnHeadersContent.style.transform = `translateX(-${scrollLeft}px)`;
        }

        function editCell(cellDiv) {
            const cellId = cellDiv.dataset.cellId;
            const currentValue = cellValues.get(cellId);

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'sheet-grid-cell-input';
            input.value = cellFormulas.get(cellId) || currentValue; // Show formula if exists, otherwise value

            cellDiv.innerHTML = ''; // Clear cell content
            cellDiv.appendChild(input);
            input.focus();

            const saveChanges = () => {
                saveCell(input, cellDiv, cellId);
            };

            input.addEventListener('blur', saveChanges);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveChanges();
                }
            });
        }

        function saveCell(inputElement, cellDiv, cellId) {
            const oldValue = cellValues.get(cellId);
            const oldFormula = cellFormulas.get(cellId);
            const newValue = inputElement.value;

            let newFormula = '';
            let newDisplayValue = '';

            if (newValue.startsWith('=')) {
                newFormula = newValue;
                cellFormulas.set(cellId, newFormula);

                // Check for AI formula
                if (newFormula.startsWith('=AI(') && newFormula.endsWith(')')) {
                    const prompt = newFormula.substring(4, newFormula.length - 1); // Extract prompt
                    cellValues.set(cellId, '#AI_LOADING...'); // Set loading state
                    cellDiv.textContent = '#AI_LOADING...'; // Update UI immediately
                    reEvaluateAllCells(); // Re-evaluate to propagate loading state

                    fetchAiResponse(prompt).then(response => {
                        const finalValue = response;
                        cellValues.set(cellId, finalValue);
                        recordChange(cellId, oldValue, oldFormula, finalValue, newFormula);
                        reEvaluateAllCells(); // Re-evaluate all cells with formulas
                        // Re-render the specific cell if it's visible
                        const cellElement = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellId}"]`);
                        if (cellElement) {
                            cellElement.textContent = finalValue;
                        }
                    }).catch(error => {
                        console.error('AI formula execution failed:', error);
                        const errorValue = `#AI_ERROR: ${error.message}`;
                        cellValues.set(cellId, errorValue);
                        recordChange(cellId, oldValue, oldFormula, errorValue, newFormula);
                        reEvaluateAllCells();
                        const cellElement = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellId}"]`);
                        if (cellElement) {
                            cellElement.textContent = errorValue;
                        }
                    });
                    newDisplayValue = '#AI_LOADING...'; // Initial display value
                } else {
                    newDisplayValue = evaluateCell(cellId);
                    cellValues.set(cellId, newDisplayValue); // Store the evaluated value
                    recordChange(cellId, oldValue, oldFormula, newDisplayValue, newFormula);
                    cellDiv.innerHTML = ''; // Clear input
                    cellDiv.textContent = newDisplayValue; // Display updated evaluated value
                    reEvaluateAllCells(); // Re-evaluate all cells with formulas as other cells might depend on this one
                }
            } else {
                cellFormulas.set(cellId, ''); // Clear formula if it's not a formula
                newDisplayValue = newValue;
                cellValues.set(cellId, newDisplayValue); // Store raw value
                recordChange(cellId, oldValue, oldFormula, newDisplayValue, newFormula);
                cellDiv.innerHTML = ''; // Clear input
                cellDiv.textContent = newDisplayValue; // Display updated evaluated value
                reEvaluateAllCells(); // Re-evaluate all cells with formulas as other cells might depend on this one
            }

            // After re-evaluation and re-rendering, explicitly re-focus the cell that was just saved
            requestAnimationFrame(() => {
                const cellToRefocus = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellId}"]`);
                if (cellToRefocus) {
                    cellToRefocus.focus();
                    currentFocusedCellElement = cellToRefocus; // Update the element reference
                }
            });
        }

        // Keyboard navigation and actions
        document.addEventListener('keydown', (e) => {
            // Allow normal input behavior in modal inputs
            if (e.target.tagName === 'INPUT' && e.target.closest('#aiSettingsModal')) {
                return;
            }
            if (e.target.tagName === 'TEXTAREA' && e.target.closest('#askAiModal')) {
                return;
            }

            // Handle global shortcuts that work even when editing
            if (e.metaKey || e.ctrlKey) {
                switch (e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        return;
                    case 'y':
                        e.preventDefault();
                        redo();
                        return;
                    case 's':
                        e.preventDefault();
                        if (e.altKey) {
                            openAiSettingsModal();
                        } else {
                            saveAsCSV();
                        }
                        return;
                    case 'a':
                        if (e.altKey) {
                            e.preventDefault();
                            openAskAiModal();
                            return;
                        }
                        break;
                    case 'o':
                        e.preventDefault();
                        openCSV();
                        return;
                    case 'n':
                        e.preventDefault();
                        resetSheet();
                        return;
                }
            }

            const isEditing = e.target.classList.contains('sheet-grid-cell-input');
            let cellIdToNavigateFrom = currentFocusedCellId;

            if (!cellIdToNavigateFrom) return;

            // If in edit mode, only handle Enter for saving. Other keys are for input.
            if (isEditing) {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent default Enter behavior (e.g., form submission)
                    e.target.blur(); // Trigger blur to save changes
                }
                return; // Let the input field handle all other keys
            }

            // If not in edit mode, handle navigation and other actions
            const focusedCell = document.querySelector(`.sheet-grid-cell[data-cell-id="${cellIdToNavigateFrom}"]`);
            if (!focusedCell) return; // Should not happen if currentFocusedCellId is valid

            let { col, row } = parseCellReference(cellIdToNavigateFrom);
            let newCol = col;
            let newRow = row;
            let needsScroll = false;

            switch (e.key) {
                case 'ArrowUp':
                    newRow = Math.max(0, row - 1);
                    needsScroll = true;
                    break;
                case 'ArrowDown':
                    newRow = Math.min(TOTAL_ROWS - 1, row + 1);
                    needsScroll = true;
                    break;
                case 'ArrowLeft':
                    newCol = Math.max(0, col - 1);
                    needsScroll = true;
                    break;
                case 'ArrowRight':
                    newCol = Math.min(TOTAL_COLUMNS - 1, col + 1);
                    needsScroll = true;
                    break;
                case 'Enter':
                    e.preventDefault(); // Prevent default Enter behavior (e.g., form submission)
                    editCell(focusedCell);
                    return;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    if (cellIdToNavigateFrom) {
                        cellValues.set(cellIdToNavigateFrom, '');
                        cellFormulas.set(cellIdToNavigateFrom, '');
                        reEvaluateAllCells();
                    }
                    return;
                case 'c':
                    if ((e.metaKey || e.ctrlKey) && e.shiftKey) {
                        e.preventDefault();
                        copyCellValue(cellIdToNavigateFrom);
                    } else if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        copyCell(cellIdToNavigateFrom);
                    }
                    return;
                case 'x':
                    if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        cutCell(cellIdToNavigateFrom);
                    }
                    return;
                case 'v':
                    if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        pasteCell(cellIdToNavigateFrom);
                    }
                    return;
            }

            if (newCol !== col || newRow !== row) {
                const newCellId = `${getColumnName(newCol)}${newRow + 1}`;
                // Check if the new row is outside the visible range
                if (newRow < startRowIdx) {
                    viewport.scrollTop = newRow * ROW_HEIGHT;
                } else if (newRow >= endRowIdx) {
                    viewport.scrollTop = (newRow - visibleRows + 1) * ROW_HEIGHT;
                }

                // Check if the new column is outside the visible range
                if (newCol < startColIdx) {
                    viewport.scrollLeft = newCol * COLUMN_WIDTH;
                } else if (newCol >= endColIdx) {
                    viewport.scrollLeft = (newCol - visibleColumns + 1) * COLUMN_WIDTH;
                }

                requestAnimationFrame(() => {
                    const newlyRenderedCell = document.querySelector(`.sheet-grid-cell[data-cell-id="${newCellId}"]`);
                    if (newlyRenderedCell) {
                        newlyRenderedCell.focus();
                    }
                });
            }
        });

        function copyCell(cellId) {
            clipboard.type = 'copy';
            clipboard.cellId = cellId;
            clipboard.value = cellValues.get(cellId);
            clipboard.formula = cellFormulas.get(cellId);
            console.log(`Copied ${cellId}: ${clipboard.formula || clipboard.value}`);
        }

        function copyCellValue(cellId) {
            clipboard.type = 'copy';
            clipboard.cellId = cellId;
            clipboard.value = cellValues.get(cellId);
            clipboard.formula = '';
            console.log(`Copied value of ${cellId}: ${clipboard.value}`);
        }

        function cutCell(cellId) {
            const oldValue = cellValues.get(cellId);
            const oldFormula = cellFormulas.get(cellId);

            clipboard.type = 'cut';
            clipboard.cellId = cellId;
            clipboard.value = oldValue;
            clipboard.formula = oldFormula;

            // Clear the original cell
            cellValues.set(cellId, '');
            cellFormulas.set(cellId, '');
            recordChange(cellId, oldValue, oldFormula, '', ''); // Record the cut action
            reEvaluateAllCells();
            console.log(`Cut ${cellId}: ${clipboard.formula || clipboard.value}`);
        }

        function pasteCell(targetCellId) {
            if (!clipboard.type || !clipboard.cellId) {
                console.log('Clipboard is empty.');
                return;
            }

            const oldValue = cellValues.get(targetCellId);
            const oldFormula = cellFormulas.get(targetCellId);

            // Apply clipboard content to the target cell
            cellValues.set(targetCellId, clipboard.value);
            cellFormulas.set(targetCellId, clipboard.formula);
            recordChange(targetCellId, oldValue, oldFormula, clipboard.value, clipboard.formula); // Record the paste action

            // If it was a cut operation, clear the source cell's clipboard status
            if (clipboard.type === 'cut') {
                // The original cell was already recorded as cleared by cutCell, so no need to record again.
                clipboard.type = null;
                clipboard.cellId = null;
                clipboard.value = null;
                clipboard.formula = null;
            }

            reEvaluateAllCells();
            console.log(`Pasted to ${targetCellId}`);
        }

        function deleteCell(cellId) {
            const oldValue = cellValues.get(cellId);
            const oldFormula = cellFormulas.get(cellId);

            cellValues.set(cellId, '');
            cellFormulas.set(cellId, '');
            recordChange(cellId, oldValue, oldFormula, '', ''); // Record the delete action
            reEvaluateAllCells();
            console.log(`Deleted content of ${cellId}`);
        }

        function saveAsCSV() {
            let csvContent = "";
            let maxRowWithContent = -1;
            let maxColWithContent = -1;

            // Determine the actual bounds of content
            for (let i = 0; i < TOTAL_ROWS; i++) {
                for (let j = 0; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    const cellContent = cellFormulas.get(cellId) || cellValues.get(cellId);
                    if (cellContent !== '' && cellContent !== null && cellContent !== undefined) {
                        if (i > maxRowWithContent) maxRowWithContent = i;
                        if (j > maxColWithContent) maxColWithContent = j;
                    }
                }
            }

            // If no content, save an empty file or a file with just headers if preferred
            if (maxRowWithContent === -1) {
                console.log('No content to save as CSV.');
                // Optionally, you could still save an empty CSV with headers:
                // const headerRow = [];
                // for (let j = 0; j <= maxColWithContent; j++) { // Include headers up to maxColWithContent
                //     headerRow.push(getColumnName(j));
                // }
                // csvContent = headerRow.join(',') + '\n';
                // For now, we'll save an empty file if no content.
            } else {
                // Generate data rows
                for (let i = 0; i <= maxRowWithContent; i++) {
                    const rowData = [];
                    for (let j = 0; j <= maxColWithContent; j++) {
                        const cellId = `${getColumnName(j)}${i + 1}`;
                        let cellContent = cellValues.get(cellId); // Export only the evaluated value

                        // Ensure content is a string for CSV formatting
                        if (cellContent === null || cellContent === undefined) {
                            cellContent = '';
                        } else if (typeof cellContent !== 'string') {
                            cellContent = String(cellContent);
                        }

                        // Escape double quotes by doubling them, then wrap in double quotes if content contains comma, double quote, or newline
                        if (cellContent.includes(',') || cellContent.includes('"') || cellContent.includes('\n')) {
                            cellContent = `"${cellContent.replace(/"/g, '""')}"`;
                        }
                        rowData.push(cellContent);
                    }
                    csvContent += rowData.join(',') + '\n';
                }
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'spreadsheet.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('Your browser does not support downloading files directly. Please copy the content manually.');
            }
            console.log('Saved as CSV');
        }

        function openCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.style.position = 'absolute';
            input.style.left = '-9999px';
            document.body.appendChild(input);

            input.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const csvContent = e.target.result;
                        parseCSV(csvContent);
                        document.body.removeChild(input);
                    };
                    reader.readAsText(file);
                } else {
                    document.body.removeChild(input);
                }
            });
            input.click();
            console.log('Opening CSV file dialog...');
        }

        function parseCSV(csvContent) {
            // Clear existing data
            cellValues.clear();
            cellFormulas.clear();
            history.length = 0; // Clear undo/redo history
            historyPointer = -1;

            const lines = csvContent.split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length === 0) {
                console.warn('CSV file is empty.');
                reEvaluateAllCells();
                return;
            }

            const headerLine = lines.shift(); // Remove header line
            const headers = parseCSVLine(headerLine); // Parse headers to determine column count

            // Determine the number of columns based on the header or the longest row
            let maxCols = headers.length;
            for (const line of lines) {
                const row = parseCSVLine(line);
                if (row.length > maxCols) {
                    maxCols = row.length;
                }
            }

            // Re-initialize cellValues and cellFormulas based on the new maxCols and lines.length
            // This ensures we have enough cells for the loaded data
            for (let i = 0; i < lines.length; i++) { // Iterate through actual data rows
                const rowData = parseCSVLine(lines[i]);
                for (let j = 0; j < maxCols; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    let content = rowData[j] !== undefined ? rowData[j] : '';

                    // Check if content is a formula
                    if (typeof content === 'string' && content.startsWith('=')) {
                        cellFormulas.set(cellId, content);
                        cellValues.set(cellId, evaluateCell(cellId)); // Evaluate and store value
                    } else {
                        cellFormulas.set(cellId, '');
                        cellValues.set(cellId, content);
                    }
                }
            }

            // If the loaded CSV has fewer rows/columns than TOTAL_ROWS/TOTAL_COLUMNS,
            // ensure the remaining cells are empty.
            for (let i = lines.length; i < TOTAL_ROWS; i++) {
                for (let j = 0; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    cellValues.set(cellId, '');
                    cellFormulas.set(cellId, '');
                }
            }
            for (let i = 0; i < TOTAL_ROWS; i++) {
                for (let j = maxCols; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    cellValues.set(cellId, '');
                    cellFormulas.set(cellId, '');
                }
            }

            reEvaluateAllCells(); // Re-evaluate all cells to update dependencies
            renderRows(); // Re-render the grid with new data
            console.log('CSV file loaded successfully.');
        }

        // Simple CSV parser that handles quoted fields
        function parseCSVLine(line) {
            const result = [];
            let inQuote = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuote && i + 1 < line.length && line[i + 1] === '"') {
                        // Escaped double quote
                        currentField += '"';
                        i++; // Skip the next quote
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) {
                    result.push(currentField);
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField); // Add the last field
            return result;
        }

        function resetSheet() {
            // Clear all cell values and formulas
            cellValues.clear();
            cellFormulas.clear();

            // Re-initialize with empty strings
            for (let i = 0; i < TOTAL_ROWS; i++) {
                for (let j = 0; j < TOTAL_COLUMNS; j++) {
                    const cellId = `${getColumnName(j)}${i + 1}`;
                    cellValues.set(cellId, '');
                    cellFormulas.set(cellId, '');
                }
            }

            // Clear undo/redo history
            history.length = 0;
            historyPointer = -1;

            // Re-render the grid
            reEvaluateAllCells();
            renderRows();
            console.log('Sheet reset successfully.');
        }

        viewport.addEventListener('scroll', handleScroll);

        // Initial render
        renderColumnHeaders();
        renderRows();

        // Handle window resize to adjust visible rows and columns
        window.addEventListener('resize', () => {
            viewportHeight = viewport.clientHeight;
            viewportWidth = viewport.clientWidth - ROW_HEADER_WIDTH;

            visibleRows = Math.ceil(viewportHeight / ROW_HEIGHT);
            visibleColumns = Math.ceil(viewportWidth / COLUMN_WIDTH);

            endRowIdx = Math.min(startRowIdx + visibleRows, TOTAL_ROWS);
            endColIdx = Math.min(startColIdx + visibleColumns, TOTAL_COLUMNS);

            renderColumnHeaders();
            renderRows();
        });
    </script>
</body>

</html>
